#include <iostream>
#include <fstream>
#include "stack.h"

using namespace std;

//короче принцип какой: в функции proceed нужно закидывать элементы в стек. почему именно стек?
//очевидно, чтоб было удобно работать. короче мы помещаем элементы в стек(учитывая, что неправильных символов здесь нет)
//ввод из файла, потому что хуле нет. и так, в чём смысл? мы помещаем в стек цифры, пока что не наткнёмся
//на символ операции. далее мы сохраняем *приоритет* этой опервции, либо саму операцию, но всё равно нужно построить
//какую то систему приоритетов для них. почему именно так? тут всё просто. если задуматься, то когда мы встречаем
//операцию, мы не должны её сразу исполнять, потому что возможно, что следующая операция имеет выше приоритет, а значит
//мы должны были сперва посчитать её (e.g. 1+2*3+5 - согласитесь, логично сначала выполнить умножение. так и выходит,
//если мы учитываем приоритет операций. смарите, берём единичку, затем +, знаем, что + или - имеют приоритет 1,
//а умножение и деление 2 (скобки 3, но я забыл их реализовать в функции ниже, хотя принцип тот же). тогда мы смотрим
//далее и ого, встречаем *, теперь мы ждём следующий оператор и если его приоритет строго меньше последнего, исполняем
//в обратном порядке, пока не встретим тот самый плюс[1]. помещаем в стек результат(т.е. мы вытягиваем 2*3 и вместо них
//пушим в стек 6, т.е. на данный момент имеем в стеке(условно) 1+6), далее встречаем +, имеющий с первым плюсом одинаковый
//приоритет, значит исполняем в обратном порядке снова и помещаем результат(имеем в стеке единственное значение 7)
//и исполняем последнее сложение, когда доходим до конца строки, потому что очевидно, дальше ничего нет. та-дам. короче
//может логично возникнуть проблема, что умножение было последней операцией, следовательно надо было ещё исполнить всё
//что было до него, ну это и должно быть реализовано в функции proceed, ща, чуть ниже опишу структуру кода
//
//короче теперь про структуру кода.
//как видно, функция execute уже готова, в ней мы исполняем операции как указано в аннотации [1] сверху, а вот приоритеты
//и прочая хуйня для работы со стеком должна быть в функции proceed или ещё в каких то, мне вообще не принципиально,
//хоть для каждой операции отдельную функцию сделать можно. строку можно объявить в мейне, но тут тоже похуй вообще.
//смысл думаю понятен: в функции proceed помещаем хуйню в стек, пока не встретим операцию, равную или большую по приоритету
//тогда переходим в функцию execute и выполняем нужную операцию, пока не надоест. у execute есть прикол, что она выполняет
//одну операцию за раз, потому что это проще. ну то есть, ей похуй какая там вообще операция, смысл в том, когда её вызвали
//а не зачем её вызвали. поэтому надо по возвращении из неё учесть, не надо ли ещё какую то операцию выполнить.
//надеюсь смысл понятен, справитесь

void execute(stack*& s) { // здесь функция уже готова, она выполняется, когда ща опишу сверху
	int mult = 1, right_operand = 0, left_operand = 0;
	char operation = 0;
	int A = pop(s);
	while (A >= '0' && A <= '9') {
		right_operand += mult * A;
		mult *= 10;
		A = pop(s);
	}
	operation = A;
	A = pop(s);
	mult = 1;
	while (!isEmpty(s->next) && (A >= 0 && A <= '9')) {
		left_operand += mult * A;
		mult *= 10;
		A = pop(s);
	}
	switch (operation) {
	case '+':
		push(s, left_operand + right_operand);
		break;
	case '-':
		push(s, left_operand - right_operand);
		break;
	case '*':
		push(s, left_operand * right_operand);
		break;
	case '/':
		push(s, left_operand / right_operand);
		break;
	}
}

void proceed(ifstream& in) { // 
	
}

int main()
{
	return 0;
}
